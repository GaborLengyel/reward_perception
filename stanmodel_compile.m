%% StanSimulation_Uniform used in bias_tracking_simulation_1session.m
model = StanModel('verbose',true);
%model.set('cmdstan_path', '/Users/glengyel/anaconda3/envs/stan/bin/cmdstan');
StanSimulation_Uniform = {
'data {'
'  int ndir;'
'  array[ndir,3] int choi;'
'  array[ndir,3] real direc;'
'  array[ndir,3] int n;'
'  real DP_minus;'
'  real DP_plus;'
'  real<lower = 0> lapse_alpha_1;'
'  real<lower = 0> lapse_beta_1;'
'  real<lower = 0> lapse_alpha_2;'
'  real<lower = 0> lapse_beta_2;'
'  real<lower = 0> phi_alpha;'
'  real<lower = 0> phi_beta;'
'  real<lower = 0> tau_1;'
'  real<lower = 0> tau_2;'
'  real<lower = 0> tau_d;'
'}'
'parameters {'
'  array[3] real<lower = 0> phi;'
'  real P_1;'
'  real P_2;'
'  real D;'
'  real<lower = 0, upper = 0.5> lapse_1;'
'  real<lower = 0, upper = 0.5> lapse_2;'
'}'
'transformed parameters {'
'  array[ndir,3] real<lower = 0, upper = 1> theta;'
'  array[3] real B;'
'  for( i in 1: ndir){'
'    theta[i, 1] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 1] | P_1 + D, phi[1]);'
'    theta[i, 2] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 2] | D, phi[2]);'
'    theta[i, 3] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 3] | P_2 + D, phi[3]);'
'  }'
'}'
'model {'
'  for (j in 1:3){'
'    for( i in 1: ndir){'
'      choi[i, j] ~ binomial(n[i, j], theta[i, j]);'
'    }'
'    phi[j] ~ gamma(phi_alpha, phi_beta);'
'  }'
'  P_1 ~ uniform(DP_minus, DP_plus);'
'  P_2 ~ uniform(DP_minus, DP_plus);'
'  D ~ uniform(DP_minus, DP_plus);'
'  lapse_1 ~ beta(lapse_alpha_1, lapse_beta_1);'
'  lapse_2 ~ beta(lapse_alpha_2, lapse_beta_2);'
'}'
'generated quantities {'
'}'
};

model.set('model_code',StanSimulation_Uniform,'model_name','StanSimulation_Uniform');
model.compile();

%% StanSimulation_Decision used in bias_tracking_simulation_1session.m
model = StanModel('verbose',true);
StanSimulation_Decision = {
'data {'
'  int ndir;'
'  array[ndir,3] int choi;'
'  array[ndir,3] real direc;'
'  array[ndir,3] int n;'
'  real P0_1;'
'  real P0_2;'
'  real D0;'
'  real<lower = 0> lapse_alpha_1;'
'  real<lower = 0> lapse_beta_1;'
'  real<lower = 0> lapse_alpha_2;'
'  real<lower = 0> lapse_beta_2;'
'  real<lower = 0> phi_alpha;'
'  real<lower = 0> phi_beta;'
'  real<lower = 0> tau_1;'
'  real<lower = 0> tau_2;'
'  real<lower = 0> tau_d;'
'}'
'parameters {'
'  array[3] real<lower = 0> phi;'
'  real P_1;'
'  real P_2;'
'  real D;'
'  real<lower = 0, upper = 0.5> lapse_1;'
'  real<lower = 0, upper = 0.5> lapse_2;'
'}'
'transformed parameters {'
'  array[ndir,3] real<lower = 0, upper = 1> theta;'
'  array[3] real B;'
'  for( i in 1: ndir){'
'    theta[i, 1] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 1] | P_1 + D, phi[1]);'
'    theta[i, 2] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 2] | D, phi[2]);'
'    theta[i, 3] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 3] | P_2 + D, phi[3]);'
'  }'
'}'
'model {'
'  for (j in 1:3){'
'    for( i in 1: ndir){'
'      choi[i, j] ~ binomial(n[i, j], theta[i, j]);'
'    }'
'    phi[j] ~ gamma(phi_alpha, phi_beta);'
'  }'
'  P_1 ~ normal(P0_1, tau_1);'
'  P_2 ~ normal(P0_2, tau_2);'
'  D ~ normal(D0, tau_d);'
'  lapse_1 ~ beta(lapse_alpha_1, lapse_beta_1);'
'  lapse_2 ~ beta(lapse_alpha_2, lapse_beta_2);'
'}'
'generated quantities {'
'}'
};
model.set('model_code',StanSimulation_Decision,'model_name','StanSimulation_Decision');
model.compile();
%% StanSession used in bias_tracking_simulation_multisession.m
model = StanModel('verbose',true);
StanSession = {
'data {'
'  int ndir;'
'  int nse;'
'  array[nse,ndir] int choi1;'
'  array[nse,ndir] int choi2;'
'  array[nse,ndir] int choi3;'
'  array[nse,ndir] real direc1;'
'  array[nse,ndir] real direc2;'
'  array[nse,ndir] real direc3;'
'  array[nse,ndir] int n1;'
'  array[nse,ndir] int n2;'
'  array[nse,ndir] int n3;'
'  real<lower = 0> lapse_alpha_1;'
'  real<lower = 0> lapse_beta_1;'
'  real<lower = 0> lapse_alpha_2;'
'  real<lower = 0> lapse_beta_2;'
'  real<lower = 0> phi_alpha;'
'  real<lower = 0> phi_beta;'
'}'
'parameters {'
'  array[nse,3] real<lower = 0> phi;'
'  array[nse] real P_1;'
'  array[nse] real P_2;'
'  array[nse] real D;'
'  array[nse] real<lower = 0, upper = 0.5> lapse_1;'
'  array[nse] real<lower = 0, upper = 0.5> lapse_2;'
'  real<lower = 0> tau_1;'
'  real<lower = 0> tau_2;'
'  real<lower = 0> tau_d;'
'  real P0_1;'
'  real P0_2;'
'}'
'transformed parameters {'
'  array[nse,ndir] real<lower = 0, upper = 1> theta1;'
'  array[nse,ndir] real<lower = 0, upper = 1> theta2;'
'  array[nse,ndir] real<lower = 0, upper = 1> theta3;'
'  for( j in 1: nse){'
'    for( i in 1: ndir){'
'      theta1[j, i] = lapse_1[j] + (1- lapse_2[j] -lapse_1[j]) * normal_cdf(direc1[j, i] | P_1[j] + D[j], phi[j, 1]);'
'      theta2[j, i] = lapse_1[j] + (1- lapse_2[j] -lapse_1[j]) * normal_cdf(direc2[j, i] | D[j], phi[j, 2]);'
'      theta3[j, i] = lapse_1[j] + (1- lapse_2[j] -lapse_1[j]) * normal_cdf(direc3[j, i] | P_2[j] + D[j], phi[j, 3]);'
'    }'
'  }'
'}'
'model {'
'  for( j in 1: nse){'
'    for( i in 1: ndir){'
'      choi1[j, i] ~ binomial(n1[j, i], theta1[j, i]);'
'      choi2[j, i] ~ binomial(n2[j, i], theta2[j, i]);'
'      choi3[j, i] ~ binomial(n3[j, i], theta3[j, i]);'
'    }'
'    phi[j, 1] ~ gamma(phi_alpha, phi_beta);'
'    phi[j, 2] ~ gamma(phi_alpha, phi_beta);'
'    phi[j, 3] ~ gamma(phi_alpha, phi_beta);'
'  }'
'  P_1 ~ normal(P0_1, tau_1);'
'  P_2 ~ normal(P0_2, tau_2);'
'  D ~ normal(0, tau_d);'
'  lapse_1 ~ beta(lapse_alpha_1, lapse_beta_1);'
'  lapse_2 ~ beta(lapse_alpha_2, lapse_beta_2);'
'  tau_1 ~ normal(0, 1000);'
'  tau_2 ~ normal(0, 1000);'
'  tau_d ~ normal(0, 1000);'
'  P0_1 ~ normal(0, 1000);'
'  P0_2 ~ normal(0, 1000);'
'}'
'generated quantities {'
'}'
};
model.set('model_code',StanSession,'model_name','StanSession');
model.compile();
%% StanSimulation used in monkey_data_fit.m
model = StanModel('verbose',true);
StanSimulation = {
'data {'
'  int ndir;'
'  array[ndir,3] int choi;'
'  array[ndir,3] real direc;'
'  array[ndir,3] int n;'
'  real P0_1;'
'  real P0_2;'
'  real<lower = 0> lapse_alpha_1;'
'  real<lower = 0> lapse_beta_1;'
'  real<lower = 0> lapse_alpha_2;'
'  real<lower = 0> lapse_beta_2;'
'  real<lower = 0> phi_alpha;'
'  real<lower = 0> phi_beta;'
'  real<lower = 0> tau_1;'
'  real<lower = 0> tau_2;'
'  real<lower = 0> tau_d;'
'}'
'parameters {'
'  array[3] real<lower = 0> phi;'
'  real P_1;'
'  real P_2;'
'  real D;'
'  real<lower = 0, upper = 0.5> lapse_1;'
'  real<lower = 0, upper = 0.5> lapse_2;'
'}'
'transformed parameters {'
'  array[ndir,3] real<lower = 0, upper = 1> theta;'
'  array[3] real B;'
'  for( i in 1: ndir){'
'    theta[i, 1] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 1] | P_1 + D, phi[1]);'
'    theta[i, 2] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 2] | D, phi[2]);'
'    theta[i, 3] = lapse_1 + (1- lapse_2 -lapse_1) * normal_cdf(direc[i, 3] | P_2 + D, phi[3]);'
'  }'
'}'
'model {'
'  for (j in 1:3){'
'    for( i in 1: ndir){'
'      choi[i, j] ~ binomial(n[i, j], theta[i, j]);'
'    }'
'    phi[j] ~ gamma(phi_alpha, phi_beta);'
'  }'
'  P_1 ~ normal(P0_1, tau_1);'
'  P_2 ~ normal(P0_2, tau_2);'
'  D ~ normal(0, tau_d);'
'  lapse_1 ~ beta(lapse_alpha_1, lapse_beta_1);'
'  lapse_2 ~ beta(lapse_alpha_2, lapse_beta_2);'
'  }'
'  generated quantities {'
'}'
};

model.set('model_code',StanSimulation,'model_name','StanSimulation');
model.compile();

%% monkey_fit_all.stan used in multisession_monkeydata_fit.m
model = StanModel('verbose',true);
monkey_fit_all = {
'data {'
'  int <lower = 0> s;'
'  array[s] real amp;'
'  array[s] real angle;'
'  array[s] real ecc;'
'  array[11, s] int n1;'
'  array[11, s] real direc1;'
'  array[11, s] int choo1;'
'  array[11, s] int n2;'
'  array[11, s] real direc2;'
'  array[11, s] int choo2;'
'  array[11, s] int n3;'
'  array[11, s] real direc3;'
'  array[11, s] int choo3;'
'}'
'parameters {'
'  array[3,s] real<lower = 0> phi;'
'  array[s] real P1;'
'  array[s] real P2;'
'  array[s] real<lower = 0> lapse1;'
'  array[s] real<lower = 0> lapse2;'
'  real<lower = 0> tau1;'
'  real<lower = 0> tau2;'
'  real<lower = 0> tau_d;'
'  real N_1;'
'  real N_2;'
'  real E_1;'
'  real E_2;'
'  array[s] real D;'
'}'
'transformed parameters {'
'  array[11, s] real<lower = 0, upper = 1> theta1;'
'  array[11, s] real<lower = 0, upper = 1> theta2;'
'  array[11, s] real<lower = 0, upper = 1> theta3;'
'  for(k in 1: s){'
'    for(i in 1: 11){ '
'      theta1[i, k] = lapse1[k] + (1 - lapse2[k] - lapse1[k]) * normal_cdf(direc1[i, k] | P1[k] + D[k], phi[1, k]);'
'      theta2[i, k] = lapse1[k] + (1 - lapse2[k] - lapse1[k]) * normal_cdf(direc2[i, k] | D[k], phi[2, k]);'
'      theta3[i, k] = lapse1[k] + (1 - lapse2[k] - lapse1[k]) * normal_cdf(direc3[i, k] | P2[k] + D[k], phi[3, k]);'
'    }'
'  }'
'}'
'model {'
'  for(k in 1: s){'
'    for( i in 1: 11){ '
'      choo1[i, k] ~ binomial(n1[i, k], theta1[i, k]);'
'      choo2[i, k] ~ binomial(n2[i, k], theta2[i, k]);'
'      choo3[i, k] ~ binomial(n3[i, k], theta3[i, k]);'
'    }'
'    phi[1, k] ~ gamma(8, 0.5);'
'    phi[2, k] ~ gamma(8, 0.5);'
'    phi[3, k] ~ gamma(8, 0.5);'
'    P1[k] ~ normal(N_1 * angle[k] + E_1 * ecc[k], tau1);'
'    P2[k] ~ normal(N_2 * angle[k] + E_2 * ecc[k], tau2);'
'    D[k] ~ normal(0, tau_d);'
'    lapse1[k] ~ beta(1, 10);'
'    lapse2[k] ~ beta(1, 10);'
'  }'
'  N_1 ~ normal(0, 1000);'
'  N_2 ~ normal(0, 1000);'
'  E_1 ~ normal(0, 1000);'
'  E_2 ~ normal(0, 1000);'
'  tau_d ~ normal(0, 1000);'
'  tau1 ~ normal(0, 1000);'
'  tau2 ~ normal(0, 1000);'
'}'
'generated quantities {'
'}'
};

model.set('model_code',monkey_fit_all,'model_name','monkey_fit_all');
model.compile();

